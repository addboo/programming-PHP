# ΑΝΤΙΚΕΙΜΕΝΟΣΤΡΕΦΗΣ ΠΡΟΓΡΑΜΜΑΤΙΣΜΟΣ


## Τί είναι ο Αντικειμενοστρεφής Προγραμματισμός
Για την ανάπτυξη ενός προγράμματος δεν είναι υποχρεωτικός ο Αντικειμενοστρεφής Προγραμματισμός. Τον χρησιμοποιούμε για σύνθετα προγράμματα γιατί μας βοηθά στην καλύτερη οργάνωση και διαχείριση του κώδικά μας. Συγκεκριμένα, εαν γράψετε ένα πρόγραμμα 200 γραμμών, τότε δεν είναι απαραίτητο να υλοποιηθεί σε Α/Π. Σε ένα πρόγραμμα όμως χιλιάδων γραμμών, τότε είναι απαραίτητο. 

Με τον Αντικειμενοστρεφή Προγραμματισμό σχεδιάζουμε καλύτερα το πρόγραμμά μας. Το χωρίζουμε σε τμήματα επιτυγχάνοντας καλύτερη δομή στον κώδικά μας. Με λίγα λόγια, με τον Α/Π γλιτώνουμε απο το απόλυτο χάος στον κώδικά μας βάζοντάς τον σε τάξη. 

Στον Αντικειμενοστρεφή Προγραμματισμό κάθε κλάση (class) κάνει μια συγκεκριμένη ενέργεια. Συνεπώς, το πρόγραμμά μας το χωρίζουμε σε κλάσεις όπου η κάθε κλάση έχει συγκεκριμένο λόγο ύπαρξης και εκτελεί συγκεκριμένες εργασίες. 


Πώς δημιουργούμε μια κλαση
Μια κλάση δημιουργείται χρησιμοποιώντας την λέξη class. Για παράδειγμα, για να δημιουργήσουμε μια κλάση με όνομα Account, τότε γράφουμε:

```
class Account     ←  Αρχή της κλάσης
{
}                 ←  Τέλος της κλάσης
```

Η κλάση που δημιουργήσαμε δεν κάνει προς το παρόν απολύτως τίποτα γιατί πολύ απλά δεν περικλύει καθόλου κώδικα. Απο αυτή την κλάση όμως μπορούμε να δημιουργήσουμε αντικείμενα. 

Τα αντικείμενα είναι το «αντίγραφο» της κλάσης (blueprint). Απο μία κλάση μπορούν να δημιουργηθούν πολλαπλά αντικείμενα που το κάθε αντικείμενο θα έχει τον ίδιο κώδικα από την κλάση που δημιουργήθηκε. 

Για παράδειγμα, μια κλάση είναι κάτι αντίστοιχο με το αρχιτεκτονικό σχέδιο ενός σπιτιού. Βάσει του αρχιτεκτινικού αυτού σχεδίου κατασκευάζουμε το σπίτι (δηλαδή το αντικείμενο). Μπορούμε βέβαια, χρησιμοποιώντας το συγκεκριμένο αρχιτεκτονικό σχέδιο να κατασκευάσουμε πολλαπλά σπίτια (δηλαδή πολλαπλά αντικείμενα). 

Παρακάτω θα δημιουργήσουμε μια κλάση Account η οποία θα εκτελεί ενέργειες που πραγματοποιούνται στις τραπεζικές μας συναλλαγές:

```php
1. <?php
2. class Αccount 
3. {
4.   //εδώ γράφουμε τον κώδικά μας
5. }
6. ?> 
```

Αρχικά θα αναλύσουμε τα δομικά στοιχεία που αποτελείται μια κλάση. Στην γραμμή 2 δηλώνουμε το όνομα της κλάσης μας. Στην συγκεκριμένη περίπτωση είναι η Account.  


## Πώς δημιουργούμε αντικείμενα
Προς το παρόν δημιουργήσαμε μια κλάση, αλλά ακόμα δεν την έχουμε χρησιμοποιήσει γιατί πολύ απλά δεν δημιουργήσαμε κανένα αντικείμενο. Παρακάτω θα δούμε πώς δημιουργούμε ένα αντικείμενο απο την κλάση Account.

```php
<?php
bob = new Account();
?>
```

Για να δημιουργήσουμε ένα νέο αντικείμενο, καλούμε την μέθοδο new. Το αντικείμενό μας πλέον έχει δημιουργηθεί και είναι το bob. Από εδώ και στο εξής, μέσα στον κώδικά μας, όποτε καλούμε το bob, θα χρησιμοποιούμε τον κώδικα που υπάρχει εντός της κλάσης Account.

Στο παραπάνω παράδειγμα δημιουργήσαμε το αντικείμενο bob απο την κλάση Account. Μπορούμε να δημιουργήσουμε πολλαπλά αντικείμενα χρησιμοποιώντας την ίδια κλάση όπως π.χ. 

```php
$maria = new Account(); 
```

Κάθε αντικείμενο τρέχει τον ίδιο κώδικα που έχουμε γράψει στην κλάση Account αλλά με διαφορετικές τιμές. Αυτός άλλωστε είναι ο σκοπός του Αντικειμενοστρεφούς προγραμματισμού.


## Πώς ομαδοποιούμε δεδομένα
Στις κλάσεις δεν είναι απαραίτητο να αποθηκεύουμε δεδομένα. Αλλά ορισμένες φορές είναι απαραίτητο. Κάθε κλάση  αποθηκεύει και τα δικά της δεδομένα όπως για παράδειγμα η Account. Στην Account εκτός απο το να αποθηκεύουμε το balance, μπορούμε να αποθηκεύσουμε το όνομα και το email του πελάτη που είναι κάτοχος του λογαριασμού. Τα δεδομένα που αποθηκεύονται στην κλάση είναι σχετικά με τον σκοπό που έχει δημιουργηθεί η κλάση. 

```php
class Account
{
  public $name;
  public $email;
  public $balance;

  function create($name, $email, $balance)
  {
    $this->name = $name;
    $this->email = $email;
    $this->balance = $balance;
  }
}
```

Το παράδειγμα με τον τραπεζικό λογαριασμό πλέον αρχίζει να γίνεται πιο κατανοητό. Όταν δημιουργούμε ένα αντικείμενο, δηλώνουμε περισσότερες παραμέτρους στα δεδομένα του αντικειμένου μας π.χ.

```php
$bob = new Account("Bob", "info@bob.com", 10.00);
```

Ένα αντικείμενο όμως, εκτός απο τα δεδομένα, περιέχει και μεθόδους οι οποίες είναι ομαδοποιημένες σύμφωνα με τον σκοπό που δημιουργήθηκε η κλάση. 

```php
class Account
{
  public $name;
  public $email;
  public $balance;
  
  function create($name, $email, $balance)
  {
    $this->name = $name;
    $this->email = $email;
    $this->balance = $balance;
  }

  function deposit($amount)
  {
    #code
  }

  function withdraw($amount)
    #code
  }
}
```

Από το παραπάνω παράδειγμα αν εξαιρέσουμε τις γραμμές 9 & 13 που δεν περιέχουν κώδικα οι μέθοδοί μας, η κλάση μας αρχίζει να παίρνει πιο ολοκληρωμένη μορφή. Ο Bob πλέον, εκτός απο το ανοίγει απλά έναν λογαριασμό, μπορεί να καταθέτει ή να κάνει ανάληψη των χρημάτων από τον τραπεζικό του λογαριασμό όταν το επιθυμεί.

Η κλάση Account, είναι σχεδόν έτοιμη. Το μόνο που απομένει, είναι να ολοκληρώσουμε τις μεθόδους deposit και withdraw. 


## Δημιουργώντας μεθόδους
Ένα σημαντικό προτέρημα όταν δημιουργούμε μεθόδους μέσα σε κλάσεις, είναι οτι τον ίδιο κώδικα μπορούμε να τον επαναχρησιμοποιούμε ταυτόχρονα πολλές φορές δημιουργώντας αντικείμενα. 

Επιπλέον, εφόσον ολοκληρωθεί η κλάση μας, τότε ο προγραμματιστής χρησιμοποιεί την μέθοδο απλώς καλώντας την μέσω του αντικειμένου που δημιουργήθηκε. Συνεπώς, τον προγραμματιστή δεν τον ενδιαφέρει πώς είναι κατασκευασμένη η μέθοδος, αλλά απλώς τί εργασία εκτελεί. Το μόνο που χρειάζεται να γνωρίζει ο προγραμματιστής, είναι οι παράμετροι της μεθόδου του αντικειμένου που έχει δημιουργήσει. Για παράδειγμα, στην κλάση `Account`, η μέθοδος `create` δέχεται τρεις παραμέτρους. Το `$name`, `$email` και  `$balance`.

Καθώς υλοποιούμε ένα αντικείμενο, πρέπει να γνωρίζουμε ακριβώς τί θα κάνει. Για παράδειγμα η μέθοδος `deposit`, θα πρέπει να προσθέτει το ποσό της κατάθεσης στην μεταβλητή `$balance` και να αποθηκεύει το αποτέλεσμα στην `$balance`.

Παρακάτω θα δούμε την υλοποίηση αυτών των δύο μεθόδων.

```php
class Account
{
  public $name;
  public $email;
  public $balance;
  
  function create($name, $email, $balance)
  {
    $this->name = $name;
    $this->email = $email;
    $this->balance = $balance;
  }

  function deposit($amount)
  {
    $this->balance += $amount;
  }

  function withdraw($amount)
    $this->balance -= $amount;
  }
}

```

Στο παραπάνω παράδειγμα, για να το χρησιμοποιήσουμε, πρέπει πρώτα να αρχικοποιήσουμε το αντικείμενο με δεδομένα, και στη συνέχεια να χρησιμοποιήσουμε τις μεθόδους `deposit()` και `widthdraw()`.

Βέβαια, για να δούμε τις τιμές που έχει ο κάθε λογαριασμός, χρειαζόμαστε να προσθέσουμε μια ακόμα μέθοδο μέσα στην κλάση `Account` με όνομα `display()`. Η display, θα εμφανίζει τις τιμές των δεδομένων του αντικειμένου μας. Παρακάτω θα την υλοποιήσουμε και θα την χρησιμοποιήσουμε για να δείτε πώς λειτουργεί.

```php
function display()
{
  echo "Name: " . $this->name;
  echo "Email: " . $this->email;
  echo "Balance: " . $this->balance;
}
```

Στο σημείο αυτό, μπορούμε να εκτελέσουμε το παράδειγμα με τον παρακάτω κώδικα.

```php
$bob_account = new Account();
$maria_account = new Account();

$bob_account->create('Bob', 'info@microsoft.com', 100);
$maria_account->create('Maria', 'info@apple.com', 200);

$bob_account->deposit(200);
$maria_account->deposit(300);

$bob_account->display();
$maria_account->display();
```

```
Αποτέλεσμα:

Name: Bob
Email: info@microsoft.com
Balance: 300

Name: Maria
Email: info@apple.com
Balance: 500
```

Παρακάτω θα βρείτε τον κώδικα ολοκληρωμένο:

```php
<?php
class Account
{
    public $name = '';
    public $email = '';
    public $balance = 200;

    function create($name, $email, $balance)
    {
        $this->name = $name;
        $this->email = $email;
        $this->balance = $balance;
    }

    function deposit($amount)
    {
        $this->balance += $amount;
    }

    function withdraw($amount)
    {
        $this->balance -= $amount;
    }

    function display()
    {
        echo "Name: " . $this->name;
        echo "Email: " . $this->email;
        echo "Balance: " . $this->balance;
    }

}

$bob_account = new Account();
$maria_account = new Account();

$bob_account->create('Bill', 'info@microsoft.com', 100);
$maria_account->create('Maria', 'info@apple.com', 200);

$bob_account->deposit(200);
$maria_account->deposit(300);

$bob_account->display();
$maria_account->display();

?>
```

## Constructors

Ο constructor είναι μια "ειδική" function η οποία εκτελείται αυτόματα όταν δημιουργείται ένα αντικείμενο (object). Κάθε φορά που δημιουργόύμε ένα αντικείμενο, καλείται τουλάχιστον ένας constructor. Σε περίπτωση που δεν δημιουργήσουμε κάποιον constructor, τότε η php δημιουργεί έναν default constructor. Οι constructors είναι χρήσιμοι για να αρχικοποιούμε τις τιμές του αντικειμένου μας.

Κανόνες δημιουργίας των constructors:

* Το όνομα του constructor πρέπει να είναι το ίδιο με αυτό της κλάσης.
* Ο constructor δεν πρέπει να επιστρέφει κάτι (χωρίς return).
* Δεν μπορεί να είναι abstract, static, final και synchronized.

Οι constructors δημιουργούνται στην php με την `__construct()`. 

```php
class Person 
{
  var $name;

  function __construct($persons_name) 
  {
    $this->name = $persons_name;
  }

  function set_name($new_name) 
  {
    $this->name = $new_name;  
  }

  function get_name() 
  {
    return $this->name;
  }
} 
```

Στην ορολογία του Αντικεμενοστρεφούς προγραμματισμού όπου functions χρησιμοποιούμε methods και όπου variables χρησιμοποιούμε properties. 

Έτσι, από εδώ και στο εξής θα ισχύει το παρακάτω:
```
Functions = Methods
Variables = Properties
```

Παρακάτω θα δημιουργήσουμε ένα αντικείμενο χρησιμοποιώντας τον παραπάνω constructor της κλάσης Person:

```php
$andreas = new person("Andreas Bourakis");
echo Andreas's full name: " . $andreas->get_name();
```

## Properties access modifiers
Μία απο τις βασικές αρχές του Αντικειμενοστρεφούς προγραμματισμού είναι η ενθυλάκωση (encapsulation). Με την ενθυλάκωση επιτυγχάνουμε ευανάγνωστο και ποιοτικότερο κώδικα εφόσον μπορούμε να θέτουμε περιορισμούς στην πρόσβαση των properties. Στην php υπάρχουν 3 modifiers.

1. public
2. private
3. protected

### Public

Η public είναι ο default modifier. Αυτό σημαίνει πως αν δεν δηλώσουμε το visibility ενός property ή μιας function, τότε λειτουργεί ως public. Τα public στοιχεία μπορούν να είναι προσβάσιμα:

* Έξω απο την κλάση μας
* Εντός της κλάσης μας
* Από μια άλλη κλάση η οποία γίνεται implement

```php
class Person 
{
  var $name;
  public $height;
  protected $social_insurance;
  private $pinn_number;

  function __construct($persons_name) 
  {
    $this->name = $persons_name;
  }

  function set_name($new_name) 
  {
    $this->name = $new_name;
  }

  function get_name() 
  {
    return $this->name;
  }
}
```
Σημείωση: Όταν δηλώνουμε μια μεταβλητή με την `var`, τότε αυτομάτως το property είναι public.

### Private
Όταν δηλώνουμε ένα property ως private, τότε περιορίζουμε την πρόσβαση μόνο εντός της κλάσης για το συγκεκριμένο property που δηλώθηκε ως private. Αυτό σημαίνει πως σε περίπτωση που κληρονομηθεί η συγκεκριμένη κλάση από μια άλλη κλάση, τότε το στοιχείο που είναι private δεν θα μπορεί να χρησιμοποιηθεί.

```php
class MyClass 
{
   private $car = "Lada";
   $driver = "Andreas";
   
   function __construct($par) 
   {
      // Statements here run every time
      // an instance of the class
      // is created.
   }
   
   function myPublicFunction() 
   {
      return("I'm visible!");
   }
   
   private function myPrivateFunction() 
   {
      return("I'm  not visible outside!");
   }
}
```

Στο παραπάνω παράδειγμα εαν η κλάση `MyClass` κληρονομηθεί από άλλη κλάση, τότε η private function με όνομα `myPrivateFunction()` δεν θα είναι ορατή και συνεπώς δεν θα μπορεί να χρησιμοποιηθεί. Το ίδιο ισχύει και για το property `$car`.

### Protected
Όταν ένα property είναι δηλωμένο ως protected, τότε μόνο η ίδια κλάση και οι κλάσσεις οι οποίες προκύπτουν από αυτή την κλάση έχουν πρόσβαση στο συγκεκριμένο property. Αυτό έχει να κάνει καθαρά με την κληρονομικότητα. 

<!--
When a property is declared 'protected', only the same class and classes derived from that class can access the property - this has to do with inheritance ...more on that later.  Properties declared as 'public' have no access restrictions, meaning anyone can access them. To help you understand this (probably) foggy aspect of OOP, try out the following code and watch how PHP reacts. Tip: read the comments in the code for more information:
-->





